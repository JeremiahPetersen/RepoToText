{"ast":null,"code":"'use strict';\n\n/**\r\n * Calculate data maxRate\r\n * @param {Number} [samplesCount= 10]\r\n * @param {Number} [min= 1000]\r\n * @returns {Function}\r\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n  min = min !== undefined ? min : 1000;\n  return function push(chunkLength) {\n    const now = Date.now();\n    const startedAt = timestamps[tail];\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n    let i = tail;\n    let bytesCount = 0;\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n    head = (head + 1) % samplesCount;\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n    if (now - firstSampleTS < min) {\n      return;\n    }\n    const passed = startedAt && now - startedAt;\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\nexport default speedometer;","map":{"version":3,"names":["speedometer","samplesCount","min","bytes","Array","timestamps","head","tail","firstSampleTS","undefined","push","chunkLength","now","Date","startedAt","i","bytesCount","passed","Math","round"],"sources":["C:/Users/forth/Desktop/RepoToText/node_modules/axios/lib/helpers/speedometer.js"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n * Calculate data maxRate\r\n * @param {Number} [samplesCount= 10]\r\n * @param {Number} [min= 1000]\r\n * @returns {Function}\r\n */\r\nfunction speedometer(samplesCount, min) {\r\n  samplesCount = samplesCount || 10;\r\n  const bytes = new Array(samplesCount);\r\n  const timestamps = new Array(samplesCount);\r\n  let head = 0;\r\n  let tail = 0;\r\n  let firstSampleTS;\r\n\r\n  min = min !== undefined ? min : 1000;\r\n\r\n  return function push(chunkLength) {\r\n    const now = Date.now();\r\n\r\n    const startedAt = timestamps[tail];\r\n\r\n    if (!firstSampleTS) {\r\n      firstSampleTS = now;\r\n    }\r\n\r\n    bytes[head] = chunkLength;\r\n    timestamps[head] = now;\r\n\r\n    let i = tail;\r\n    let bytesCount = 0;\r\n\r\n    while (i !== head) {\r\n      bytesCount += bytes[i++];\r\n      i = i % samplesCount;\r\n    }\r\n\r\n    head = (head + 1) % samplesCount;\r\n\r\n    if (head === tail) {\r\n      tail = (tail + 1) % samplesCount;\r\n    }\r\n\r\n    if (now - firstSampleTS < min) {\r\n      return;\r\n    }\r\n\r\n    const passed = startedAt && now - startedAt;\r\n\r\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\r\n  };\r\n}\r\n\r\nexport default speedometer;\r\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,YAAY,EAAEC,GAAG,EAAE;EACtCD,YAAY,GAAGA,YAAY,IAAI,EAAE;EACjC,MAAME,KAAK,GAAG,IAAIC,KAAK,CAACH,YAAY,CAAC;EACrC,MAAMI,UAAU,GAAG,IAAID,KAAK,CAACH,YAAY,CAAC;EAC1C,IAAIK,IAAI,GAAG,CAAC;EACZ,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,aAAa;EAEjBN,GAAG,GAAGA,GAAG,KAAKO,SAAS,GAAGP,GAAG,GAAG,IAAI;EAEpC,OAAO,SAASQ,IAAIA,CAACC,WAAW,EAAE;IAChC,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;IAEtB,MAAME,SAAS,GAAGT,UAAU,CAACE,IAAI,CAAC;IAElC,IAAI,CAACC,aAAa,EAAE;MAClBA,aAAa,GAAGI,GAAG;IACrB;IAEAT,KAAK,CAACG,IAAI,CAAC,GAAGK,WAAW;IACzBN,UAAU,CAACC,IAAI,CAAC,GAAGM,GAAG;IAEtB,IAAIG,CAAC,GAAGR,IAAI;IACZ,IAAIS,UAAU,GAAG,CAAC;IAElB,OAAOD,CAAC,KAAKT,IAAI,EAAE;MACjBU,UAAU,IAAIb,KAAK,CAACY,CAAC,EAAE,CAAC;MACxBA,CAAC,GAAGA,CAAC,GAAGd,YAAY;IACtB;IAEAK,IAAI,GAAG,CAACA,IAAI,GAAG,CAAC,IAAIL,YAAY;IAEhC,IAAIK,IAAI,KAAKC,IAAI,EAAE;MACjBA,IAAI,GAAG,CAACA,IAAI,GAAG,CAAC,IAAIN,YAAY;IAClC;IAEA,IAAIW,GAAG,GAAGJ,aAAa,GAAGN,GAAG,EAAE;MAC7B;IACF;IAEA,MAAMe,MAAM,GAAGH,SAAS,IAAIF,GAAG,GAAGE,SAAS;IAE3C,OAAOG,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,UAAU,GAAG,IAAI,GAAGC,MAAM,CAAC,GAAGR,SAAS;EACpE,CAAC;AACH;AAEA,eAAeT,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}